<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ assistant_name }}</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="/static/globals.css">
    <style>
        /* Use Tailwind for most styling, add only component-specific styles */

        /* Force custom colors (Tailwind CDN doesn't support CSS var arbitrary values) */
        body {
            background-color: var(--color-background) !important;
            color: var(--color-foreground) !important;
        }

        header {
            background-color: var(--color-bg-light) !important;
            border-color: var(--color-bg-dark) !important;
        }

        header h1 {
            color: var(--color-accent) !important;
        }

        #input-container {
            background-color: var(--color-bg-light) !important;
            border-color: var(--color-bg-dark) !important;
        }

        #message-input {
            background-color: var(--color-background) !important;
            color: var(--color-foreground) !important;
            border-color: var(--color-bg-dark) !important;
        }

        #message-input:focus {
            border-color: var(--color-accent) !important;
        }

        #send-btn {
            background-color: var(--color-accent) !important;
        }

        /* Message animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        .message-group {
            animation: fadeIn 0.3s ease;
        }

        .tool-status-icon.pending {
            border: 2px solid var(--color-accent);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .thinking-dots span {
            animation: pulse 1.4s ease-in-out infinite;
        }

        .thinking-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thinking-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        .tool-result.collapsed {
            max-height: 4em;
            overflow: hidden;
            position: relative;
        }

        .tool-result.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2em;
            background: linear-gradient(transparent, var(--color-bg-dark));
        }

        /* Message bubble colors and sizing */
        .message-group.user > div:first-child {
            background-color: var(--color-bg-light) !important;
            width: fit-content !important;
            max-width: 80% !important;
        }

        .message-group.assistant .assistant-text {
            background-color: var(--color-bg-dark) !important;
            border-color: var(--color-bg-light) !important;
            width: fit-content !important;
            max-width: 85% !important;
        }

        .tool-execution {
            background-color: rgba(70, 70, 70, 0.5) !important; /* var(--color-bg-light) with 50% opacity */
            border-left-color: var(--color-accent) !important;
            width: fit-content !important;
            max-width: 85% !important;
        }

        .tool-name {
            color: var(--color-accent) !important;
        }

        .iteration-indicator {
            background-color: var(--color-bg-light) !important;
            color: var(--color-accent) !important;
        }

        .thinking-dots span {
            background-color: var(--color-accent) !important;
        }

        .copy-button:hover {
            color: var(--color-accent) !important;
        }
    </style>
</head>
<body class="flex flex-col h-screen bg-[var(--color-background)] text-[var(--color-foreground)] font-['Figtree']">
    <header class="bg-[var(--color-bg-light)] px-4 py-3 text-center border-b border-[var(--color-bg-dark)]">
        <h1 class="text-[var(--color-accent)] text-2xl font-['Octarine']">{{ assistant_name }}</h1>
    </header>

    <div id="chat-container" class="flex-1 overflow-y-auto p-4 flex flex-col gap-4"></div>

    <div id="input-container" class="p-4 bg-[var(--color-bg-light)] border-t border-[var(--color-bg-dark)] flex gap-2">
        <input type="text" id="message-input" placeholder="Type your message..." autofocus
               class="flex-1 px-4 py-3 border border-[var(--color-bg-dark)] rounded-lg bg-[var(--color-background)] text-[var(--color-foreground)] text-base outline-none focus:border-[var(--color-accent)]">
        <button id="send-btn" class="px-6 py-3 bg-[var(--color-accent)] text-white border-none rounded-lg cursor-pointer text-base hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed">Send</button>
    </div>

    <script>
        const chatContainer = document.getElementById("chat-container");
        const messageInput = document.getElementById("message-input");
        const sendBtn = document.getElementById("send-btn");

        let ws = null;
        let chatState = {
            currentMessage: null,
            isProcessing: false
        };

        // Utility functions
        function generateId() {
            return `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        }

        function formatTimestamp(isoString) {
            const date = new Date(isoString);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);

            if (diffMins < 1) return "Just now";
            if (diffMins < 60) return `${diffMins}m ago`;

            const diffHours = Math.floor(diffMins / 60);
            if (diffHours < 24) return `${diffHours}h ago`;

            return date.toLocaleDateString();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function copyToClipboard(text, button) {
            try {
                await navigator.clipboard.writeText(text);
                const originalHTML = button.innerHTML;
                button.innerHTML = 'âœ“ Copied';
                button.classList.add('text-green-500');
                setTimeout(() => {
                    button.innerHTML = originalHTML;
                    button.classList.remove('text-green-500');
                }, 2000);
            } catch (err) {
                console.error('Copy failed:', err);
            }
        }

        // Render functions
        function renderUserMessage(content, timestamp) {
            const messageGroup = document.createElement('div');
            messageGroup.className = 'message-group user flex flex-col items-end gap-1';

            messageGroup.innerHTML = `<div class="bg-[var(--color-bg-light)] text-white px-4 py-3 rounded-2xl rounded-br-md max-w-[80%] shadow-md whitespace-pre-wrap">${escapeHtml(content)}</div><div class="flex items-center gap-3 px-2 text-xs text-[var(--color-subtext)] opacity-70"><span class="timestamp">${formatTimestamp(timestamp)}</span><button class="copy-button hover:text-[var(--color-accent)] transition-colors cursor-pointer">ðŸ“‹ Copy</button></div>`;

            // Add copy button event listener with closure to capture original text
            const copyBtn = messageGroup.querySelector('.copy-button');
            copyBtn.addEventListener('click', function() {
                copyToClipboard(content, this);
            });

            chatContainer.appendChild(messageGroup);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            return messageGroup;
        }

        function renderAssistantMessage(id) {
            const messageGroup = document.createElement('div');
            messageGroup.className = 'message-group assistant flex flex-col items-start gap-1';
            messageGroup.id = id;

            messageGroup.innerHTML = `<div class="message-content assistant-text bg-[var(--color-bg-dark)] border border-[var(--color-bg-light)] text-white px-4 py-3 rounded-2xl rounded-bl-md max-w-[85%] shadow-md whitespace-pre-wrap"></div><div class="message-metadata flex items-center gap-3 px-2 text-xs text-[var(--color-subtext)] opacity-70"><span class="timestamp"></span><button class="copy-button hover:text-[var(--color-accent)] transition-colors cursor-pointer">ðŸ“‹ Copy</button></div>`;

            // Add copy button event listener
            const copyBtn = messageGroup.querySelector('.copy-button');
            copyBtn.addEventListener('click', function() {
                copyAssistantMessage(id);
            });

            chatContainer.appendChild(messageGroup);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            return messageGroup;
        }

        function appendToAssistantMessage(messageGroup, chunk) {
            const textContent = messageGroup.querySelector('.message-content.assistant-text');
            textContent.textContent += chunk;
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function addIterationIndicator(messageGroup, iteration, total) {
            let indicator = messageGroup.querySelector('.iteration-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.className = 'iteration-indicator inline-flex items-center gap-1 bg-[var(--color-bg-light)] px-3 py-1 rounded-full text-xs text-[var(--color-accent)] mb-2';
                messageGroup.insertBefore(indicator, messageGroup.firstChild);
            }
            indicator.innerHTML = `ðŸ”„ Iteration ${iteration}${total ? `/${total}` : ''}`;
        }

        function addToolExecution(messageGroup, toolName, params) {
            const toolId = `tool-${generateId()}`;
            const toolBlock = document.createElement('div');
            toolBlock.className = 'tool-execution bg-[var(--color-bg-light)]/50 border-l-4 border-[var(--color-accent)] rounded-md p-3 ml-4 my-2 max-w-[85%]';
            toolBlock.id = toolId;

            const truncatedParams = params && params.length > 50 ? params.substring(0, 50) + '...' : params;

            toolBlock.innerHTML = `<div class="tool-header flex items-center gap-2 cursor-pointer" data-tool-id="${toolId}"><div class="tool-status-icon pending w-4 h-4 flex-shrink-0"></div><span class="tool-name text-[var(--color-accent)] text-sm font-mono">${escapeHtml(toolName)}</span>${params ? `<span class="tool-params text-[var(--color-subtext)] text-xs">(${escapeHtml(truncatedParams)})</span>` : ''}</div><div class="tool-result collapsed mt-2 p-2 bg-black/30 rounded text-sm text-[var(--color-subtext)] font-mono cursor-pointer" style="display: none;"><em>Executing...</em></div>`;

            // Add click handlers
            const header = toolBlock.querySelector('.tool-header');
            const result = toolBlock.querySelector('.tool-result');
            header.addEventListener('click', () => toggleToolResult(toolId));
            result.addEventListener('click', () => toggleToolResult(toolId));

            // Insert tool before the text content div (so tools appear above text)
            const textDiv = messageGroup.querySelector('.message-content.assistant-text');
            messageGroup.insertBefore(toolBlock, textDiv);

            chatContainer.scrollTop = chatContainer.scrollHeight;
            return toolId;
        }

        function toggleToolResult(toolId) {
            const toolBlock = document.getElementById(toolId);
            if (!toolBlock) return;

            const result = toolBlock.querySelector('.tool-result');
            result.classList.toggle('collapsed');
        }

        function updateToolResult(toolId, result, durationMs) {
            const toolBlock = document.getElementById(toolId);
            if (!toolBlock) return;

            const statusIcon = toolBlock.querySelector('.tool-status-icon');
            statusIcon.classList.remove('pending');
            statusIcon.classList.add('text-green-500');
            statusIcon.innerHTML = 'âœ“';

            const resultDiv = toolBlock.querySelector('.tool-result');
            resultDiv.textContent = result;
            resultDiv.style.display = 'block';

            const header = toolBlock.querySelector('.tool-header');
            const duration = document.createElement('span');
            duration.className = 'ml-auto text-xs text-[var(--color-subtext)]';
            duration.textContent = `${durationMs}ms`;
            header.appendChild(duration);
        }

        function showThinkingIndicator() {
            const existing = document.querySelector('.thinking-indicator');
            if (existing) existing.remove();

            const thinking = document.createElement('div');
            thinking.className = 'thinking-indicator flex justify-center items-center gap-2 py-3 text-[var(--color-subtext)] italic';
            thinking.innerHTML = `<span>Thinking</span><div class="thinking-dots flex gap-1"><span class="w-2 h-2 bg-[var(--color-accent)] rounded-full"></span><span class="w-2 h-2 bg-[var(--color-accent)] rounded-full"></span><span class="w-2 h-2 bg-[var(--color-accent)] rounded-full"></span></div>`;
            chatContainer.appendChild(thinking);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function hideThinkingIndicator() {
            const thinking = document.querySelector('.thinking-indicator');
            if (thinking) thinking.remove();
        }

        function copyAssistantMessage(messageId) {
            const messageGroup = document.getElementById(messageId);
            if (!messageGroup) return;

            let text = '';
            const textContent = messageGroup.querySelector('.message-content.assistant-text');
            if (textContent) text += textContent.textContent;

            const toolBlocks = messageGroup.querySelectorAll('.tool-execution');
            toolBlocks.forEach(tool => {
                const name = tool.querySelector('.tool-name').textContent;
                const result = tool.querySelector('.tool-result').textContent;
                text += `\n\n[Tool: ${name}]\n${result}`;
            });

            const button = messageGroup.querySelector('.copy-button');
            copyToClipboard(text.trim(), button);
        }

        // WebSocket handling
        function connect() {
            const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
            ws = new WebSocket(`${protocol}//${window.location.host}/ws/chat`);

            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    handleMessage(msg);
                } catch (e) {
                    console.error('Failed to parse message:', event.data, e);
                }
            };

            ws.onclose = () => setTimeout(connect, 1000);
            ws.onerror = (error) => console.error('WebSocket error:', error);
        }

        function handleMessage(msg) {
            switch (msg.type) {
                case 'user_message':
                    renderUserMessage(msg.content, msg.timestamp);
                    break;

                case 'assistant_chunk':
                    if (!chatState.currentMessage) {
                        // Hide thinking indicator when first chunk arrives
                        hideThinkingIndicator();
                        const id = generateId();
                        const messageGroup = renderAssistantMessage(id);
                        chatState.currentMessage = {
                            id,
                            element: messageGroup,
                            tools: [],
                            text: ''
                        };
                    }
                    chatState.currentMessage.text += msg.content;
                    appendToAssistantMessage(chatState.currentMessage.element, msg.content);
                    break;

                case 'thinking':
                    if (chatState.currentMessage) {
                        addIterationIndicator(chatState.currentMessage.element, msg.iteration);
                    }
                    showThinkingIndicator();
                    break;

                case 'tool_start':
                    hideThinkingIndicator();
                    if (!chatState.currentMessage) {
                        const id = generateId();
                        const messageGroup = renderAssistantMessage(id);
                        chatState.currentMessage = {
                            id,
                            element: messageGroup,
                            tools: [],
                            text: ''
                        };
                    }

                    const toolId = addToolExecution(
                        chatState.currentMessage.element,
                        msg.tool_name,
                        msg.params
                    );
                    chatState.currentMessage.tools.push({
                        toolId,
                        name: msg.tool_name,
                        iteration: msg.iteration
                    });

                    if (msg.iteration > 1) {
                        addIterationIndicator(chatState.currentMessage.element, msg.iteration);
                    }
                    break;

                case 'tool_result':
                    hideThinkingIndicator();
                    const tool = chatState.currentMessage?.tools.find(t => t.iteration === msg.iteration);
                    if (tool) {
                        updateToolResult(tool.toolId, msg.result, msg.duration_ms);
                    }
                    break;

                case 'subagent_tool_start':
                    // Subagent is calling a tool - show it with indent
                    if (chatState.currentMessage) {
                        const toolId = addToolExecution(
                            chatState.currentMessage.element,
                            `â†³ [${msg.subagent}] ${msg.tool_name}`,
                            msg.params
                        );
                        chatState.currentMessage.tools.push({
                            toolId,
                            name: msg.tool_name,
                            subagent: msg.subagent,
                            iteration: msg.iteration
                        });
                    }
                    break;

                case 'subagent_tool_end':
                    // Subagent tool completed
                    if (chatState.currentMessage) {
                        const subagentTool = chatState.currentMessage.tools
                            .reverse()
                            .find(t => t.name === msg.tool_name && t.subagent);
                        if (subagentTool) {
                            const durationMs = Math.round(msg.duration * 1000);
                            updateToolResult(subagentTool.toolId, msg.result, durationMs);
                        }
                        chatState.currentMessage.tools.reverse(); // restore order
                    }
                    break;

                case 'end':
                    hideThinkingIndicator();

                    // Clear any leftover pending tools (spinners that never got results)
                    if (chatState.currentMessage) {
                        chatState.currentMessage.tools.forEach(tool => {
                            const toolBlock = document.getElementById(tool.toolId);
                            if (toolBlock) {
                                const statusIcon = toolBlock.querySelector('.tool-status-icon');
                                if (statusIcon && statusIcon.classList.contains('pending')) {
                                    // Tool never got a result - remove it
                                    toolBlock.remove();
                                }
                            }
                        });
                    }

                    if (chatState.currentMessage && msg.total_iterations > 1) {
                        addIterationIndicator(
                            chatState.currentMessage.element,
                            msg.total_iterations,
                            msg.total_iterations
                        );
                    }

                    // Update timestamp
                    if (chatState.currentMessage) {
                        const timestamp = chatState.currentMessage.element.querySelector('.timestamp');
                        if (timestamp) timestamp.textContent = formatTimestamp(msg.timestamp);
                    }

                    chatState.currentMessage = null;
                    chatState.isProcessing = false;
                    sendBtn.disabled = false;
                    messageInput.disabled = false;
                    messageInput.focus();
                    break;

                case 'error':
                    hideThinkingIndicator();
                    console.error('Server error:', msg.message);
                    chatState.isProcessing = false;
                    sendBtn.disabled = false;
                    messageInput.disabled = false;
                    break;

                default:
                    console.warn('Unknown message type:', msg.type);
            }
        }

        function sendMessage() {
            const text = messageInput.value.trim();
            if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;

            messageInput.value = "";
            sendBtn.disabled = true;
            messageInput.disabled = true;
            chatState.isProcessing = true;

            ws.send(text);

            // Show thinking indicator while waiting for first response
            showThinkingIndicator();
        }

        sendBtn.addEventListener("click", sendMessage);
        messageInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        connect();
    </script>
</body>
</html>
